//! Sequencer track module.

use heapless::spsc::Queue;

use crate::event::Event;
use crate::params::{Pitch, Velocity};
use crate::pattern::Pattern;

/// Capacity of the event queue.
pub const EVENT_QUEUE_CAPACITY: usize = 16;

/// Sequencer track.
#[derive(Default)]
pub struct Track {
    /// Pattern containing step information.
    pattern: Pattern,

    /// Queue for events generated by tracks.
    event_queue: EventQueue,
}

impl Track {
    /// Returns a new instance.
    pub fn new() -> Self {
        Self {
            pattern: Pattern::new(),
            event_queue: EventQueue::new(),
        }
    }

    /// Process a clock pulse.
    pub fn clock(&mut self, pulse_no: i32) {
        // Test only
        if pulse_no / 96 % 4 == 0 {
            self.event_queue
                .enqueue(Event::NoteOn(Pitch::Default, Velocity::Normal))
                .ok();
        }
        if pulse_no / 96 % 4 == 2 {
            self.event_queue
                .enqueue(Event::NoteOff(Pitch::Default))
                .ok();
        }
    }

    /// Return next event.
    pub fn next_event(&mut self) -> Option<Event> {
        self.event_queue.dequeue()
    }
}

/// Event queue.
type EventQueue = Queue<Event, EVENT_QUEUE_CAPACITY>;
