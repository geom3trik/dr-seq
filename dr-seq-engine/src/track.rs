//! Sequencer track module.

use heapless::spsc::Queue;

use crate::event::TrackEvent;
use crate::params::{Pitch, Velocity};
use crate::pattern::Pattern;

/// Capacity of the event queue.
pub const EVENT_QUEUE_CAPACITY: usize = 16;

/// Sequencer track.
/// - `BARS` is the max number of bars in each pattern.
/// - `PPQ` is the resolution in pulses per quarter note.
#[derive(Default, Debug)]
pub struct Track<const BARS: usize, const PPQ: u32> {
    /// Flag if track is enabled for playing.
    enabled: bool,

    /// Play position as step number.
    play_pos: Option<u32>,

    /// Delay in pulses.
    delay: i32,

    /// Pattern containing step information.
    pattern: Pattern<BARS>,

    /// Queue for events generated by tracks.
    event_queue: EventQueue,
}

impl<const BARS: usize, const PPQ: u32> Clone for Track<BARS, PPQ> {
    /// Clones the track data but creates a new event queue.
    fn clone(&self) -> Self {
        Self {
            enabled: false,
            play_pos: None,
            delay: self.delay,
            pattern: self.pattern.clone(),
            event_queue: EventQueue::new(),
        }
    }
}

impl<const BARS: usize, const PPQ: u32> Track<BARS, PPQ> {
    /// Returns a new instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Process a clock pulse.
    pub fn clock(&mut self, pulse_no: i32) {
        if self.enabled {
            let pulse_no = pulse_no - self.delay;
            let play_pos =
                (pulse_no / (PPQ as i32 / 4) % self.pattern.length_steps() as i32) as u32;

            if self.play_pos.is_none() || play_pos != self.play_pos.unwrap() {
                self.play_pos = Some(play_pos);
                let play_bar = play_pos / 16;
                let play_step = play_pos % 16;

                if self.pattern.bar(play_bar).step(play_step).enabled() {
                    // For now, we don't use a specific gate time.
                    self.event_queue
                        .enqueue(TrackEvent::NoteOn(Pitch::Default, Velocity::Default))
                        .ok();
                    self.event_queue
                        .enqueue(TrackEvent::NoteOff(Pitch::Default))
                        .ok();
                }
            }
        }
    }

    /// Return next event.
    pub fn next_event(&mut self) -> Option<TrackEvent> {
        self.event_queue.dequeue()
    }

    /// Enable the track.
    pub fn enable(&mut self) {
        self.enabled = true;
    }

    /// Disable the track.
    pub fn disable(&mut self) {
        self.enabled = false;
    }

    /// Returns if the track is enabled.
    pub fn enabled(&self) -> bool {
        self.enabled
    }

    /// Sets the track delay in pulses.
    pub fn set_delay(&mut self, delay: i32) {
        self.delay = delay;
    }

    /// Returns the track delay in pulses.
    pub fn delay(&self) -> i32 {
        self.delay
    }

    /// Returns a mutable reference to the pattern.
    pub fn pattern(&mut self) -> &mut Pattern<BARS> {
        &mut self.pattern
    }
}

/// Event queue.
type EventQueue = Queue<TrackEvent, EVENT_QUEUE_CAPACITY>;
