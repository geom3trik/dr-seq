//! Sequencer track module.

use heapless::spsc::Queue;

use crate::event::TrackEvent;
use crate::params::Pitch;
use crate::pattern::Pattern;

/// Capacity of the event queue.
pub const EVENT_QUEUE_CAPACITY: usize = 16;

/// Sequencer track.
/// - `BARS` is the max number of bars in each pattern.
/// - `PPQ` is the resolution in pulses per quarter note.
#[derive(Default, Debug)]
pub struct Track<const BARS: usize, const PPQ: u32> {
    /// Flag if track is enabled for playing.
    enabled: bool,

    /// Last play position as step number over all bars.
    play_pos: Option<u32>,

    /// Swing offset in pulses.
    swing: i32,

    /// Delay in pulses.
    delay: i32,

    /// Pattern containing step information.
    pattern: Pattern<BARS>,

    /// Monotonic pulse count. Used for note off scheduling.
    pulse_count: u32,

    /// Pulse number and pitch when note off for next note off event.
    scheduled_note_off: Option<(u32, Pitch)>,

    /// Queue for events generated by tracks.
    event_queue: EventQueue,
}

impl<const BARS: usize, const PPQ: u32> Clone for Track<BARS, PPQ> {
    /// Clones the track data but creates a new event queue.
    fn clone(&self) -> Self {
        Self {
            enabled: false,
            play_pos: None,
            swing: self.swing,
            delay: self.delay,
            pattern: self.pattern.clone(),
            pulse_count: 0,
            scheduled_note_off: None,
            event_queue: EventQueue::new(),
        }
    }
}

impl<const BARS: usize, const PPQ: u32> Track<BARS, PPQ> {
    /// Returns a new instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Process a clock pulse.
    pub fn clock(&mut self, pulse_no: i32) {
        let mut pulse_no = pulse_no - self.delay;

        // Apply swing value to each 2nd step.
        if pulse_no / (PPQ as i32 / 4) % 2 == 1 {
            pulse_no -= self.swing;
        }

        // Do some calculations to determine where we are.
        let play_pos = (pulse_no / (PPQ as i32 / 4) % self.pattern.length_steps() as i32) as u32;
        let play_bar = play_pos / 16;
        let play_step = play_pos % 16;

        // Check if a previously started note has reached its length.
        if let Some(scheduled_note_off) = self.scheduled_note_off {
            if self.pulse_count == scheduled_note_off.0 {
                self.event_queue
                    .enqueue(TrackEvent::NoteOff {
                        bar: play_bar,
                        step: play_step,
                        pitch: scheduled_note_off.1,
                    })
                    .ok();
                self.scheduled_note_off = None;
            }
        }

        if self.enabled && (self.play_pos.is_none() || play_pos != self.play_pos.unwrap()) {
            self.play_pos = Some(play_pos);

            let step = self.pattern.bar(play_bar).step(play_step);

            if step.enabled() {
                // If a note is still playing, it must be stopped before triggering a new one.
                if let Some(scheduled_note_off) = self.scheduled_note_off {
                    self.event_queue
                        .enqueue(TrackEvent::NoteOff {
                            bar: play_bar,
                            step: play_step,
                            pitch: scheduled_note_off.1,
                        })
                        .ok();
                    self.scheduled_note_off = None;
                }

                // Start a new note.
                self.event_queue
                    .enqueue(TrackEvent::NoteOn {
                        bar: play_bar,
                        step: play_step,
                        pitch: step.pitch(),
                        vel: step.velocity(),
                    })
                    .ok();

                // Schedule the note off for a 1/32 note length.
                let note_off_pulse = self.pulse_count + PPQ / 8;
                self.scheduled_note_off = Some((note_off_pulse, step.pitch()));
            }
        }

        // Pulse count is allowed to overflow explicitely.
        // But it can take a while until that happens.
        self.pulse_count = self.pulse_count.wrapping_add(1);
    }

    /// Return next event.
    pub fn next_event(&mut self) -> Option<TrackEvent> {
        self.event_queue.dequeue()
    }

    /// Flush sustaining notes.
    pub fn flush(&mut self) {
        if let Some(scheduled_note_off) = self.scheduled_note_off {
            let play_pos = self.play_pos.unwrap_or_default();
            let play_bar = play_pos / 16;
            let play_step = play_pos % 16;
            self.event_queue
                .enqueue(TrackEvent::NoteOff {
                    bar: play_bar,
                    step: play_step,
                    pitch: scheduled_note_off.1,
                })
                .ok();
            self.scheduled_note_off = None;
        }
    }

    /// Enable the track.
    pub fn enable(&mut self) {
        self.enabled = true;
    }

    /// Disable the track.
    pub fn disable(&mut self) {
        self.enabled = false;
    }

    /// Sets the enabled state.
    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
    }

    /// Returns if the track is enabled.
    pub fn enabled(&self) -> bool {
        self.enabled
    }

    /// Sets the swing in pulses.
    pub fn set_swing(&mut self, swing: i32) {
        self.swing = swing;
    }

    /// Returns the swing in pulses.
    pub fn swing(&mut self) -> i32 {
        self.swing
    }

    /// Sets the track delay in pulses.
    pub fn set_delay(&mut self, delay: i32) {
        self.delay = delay;
    }

    /// Returns the track delay in pulses.
    pub fn delay(&self) -> i32 {
        self.delay
    }

    /// Returns a mutable reference to the pattern.
    pub fn pattern(&mut self) -> &mut Pattern<BARS> {
        &mut self.pattern
    }

    /// Returns the last play position as step number over all bars.
    pub fn play_pos(&self) -> Option<u32> {
        self.play_pos
    }

    /// Returns the last played bar number.
    pub fn play_bar(&self) -> Option<u32> {
        self.play_pos.map(|v| v / 16)
    }

    /// Returns the last played step number inside a bar.
    pub fn play_step(&self) -> Option<u32> {
        self.play_pos.map(|v| v % 16)
    }
}

/// Event queue.
type EventQueue = Queue<TrackEvent, EVENT_QUEUE_CAPACITY>;
